/**
 * @file Firestore Security Rules for Huddle Application
 *
 * @core_philosophy This ruleset enforces a strict security model based on ownership,
 * roles, and shared access patterns. It leverages denormalization to ensure
 * authorization independence and prevent costly `get()` operations.
 *
 * @data_structure The data is organized hierarchically, with user-specific data nested
 * under `/users/{userId}`, company-wide data in top-level collections like
 * `/companies` and `/channels`, and project-related data under `/projects/{projectId}`.
 *
 * @key_security_decisions
 *   - All write operations require authentication.
 *   - Listing of user documents is only allowed for the owner.
 *   - Denormalization is used extensively to avoid `get()` calls in rules.
 *   - Authorization is performed using helper functions for clarity and maintainability.
 *
 * @denormalization_strategy The ruleset relies heavily on denormalization. For example, channel
 * messages contain the channel's member list to avoid needing to read the channel
 * document for every message access. Similarly, companyId is included in nearly every document
 * to allow for company-scoped authorization.
 *
 * @structural_segregation Private user data is stored under `/users/{userId}`, while company-wide
 * data resides in top-level collections. This simplifies security rules and improves
 * performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @path N/A
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the document.
     * @path N/A
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the document and the document exists.
     * @path N/A
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the current user is an admin.
     * @path N/A
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Grants or denies permissions to documents representing the admin role.
     * @path /roles_admin/{uid}
     * @allow (create) If the authenticated user's UID matches the `uid` parameter.
     * @deny (create) If the authenticated user is not an admin
     */
    match /roles_admin/{uid} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin();
    }


    /**
     * @description Manages user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (get, list) If the authenticated user's UID matches the `userId` parameter.
     * @allow (create) If the authenticated user's UID matches the `userId` parameter.
     * @allow (update, delete) If the authenticated user's UID matches the `userId` parameter and the document exists.
     * @deny (get, list) If the authenticated user's UID does not match the `userId` parameter.
     * @deny (create) If the authenticated user's UID does not match the `userId` parameter.
     * @deny (update, delete) If the authenticated user's UID does not match the `userId` parameter.
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages company information.  No specific write rules implemented in this prototype, all write access is denied.
     * @path /companies/{companyId}
     * @allow (get, list) Public read access to company information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /companies/{companyId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages communication channels. Allows read/write access to members of the channel.
     * @path /channels/{channelId}
     * @allow (get, list) If the authenticated user is a member of the channel.
     * @allow (create, update, delete) If the authenticated user is a member of the channel.
     * @deny (get, list) If the authenticated user is not a member of the channel.
     * @deny (create, update, delete) If the authenticated user is not a member of the channel.
     * @principle Enforces shared access based on channel membership.
     */
    match /channels/{channelId} {
      allow get, list: if isSignedIn() && request.auth.uid in resource.data.members;
      allow create: if isSignedIn() && request.resource.data.members.hasAll([request.auth.uid]);
      allow update: if isSignedIn() && request.auth.uid in resource.data.members;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.members && resource != null;
    }

    /**
     * @description Manages messages within a channel.  Allows read/write access to members of the channel.
     * @path /channels/{channelId}/messages/{messageId}
     * @allow (get, list) If the authenticated user is a member of the parent channel.
     * @allow (create, update, delete) If the authenticated user is a member of the parent channel.
     * @deny (get, list) If the authenticated user is not a member of the parent channel.
     * @deny (create, update, delete) If the authenticated user is not a member of the parent channel.
     * @principle Enforces shared access based on channel membership, denormalized for authorization independence.
     */
    match /channels/{channelId}/messages/{messageId} {
      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/channels/$(channelId)).data.members.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/channels/$(channelId)).data.members.hasAny([request.auth.uid]) && request.resource.data.fromUid == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/channels/$(channelId)).data.members.hasAny([request.auth.uid]) && request.resource.data.fromUid == resource.data.fromUid;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/channels/$(channelId)).data.members.hasAny([request.auth.uid]) && resource != null && request.resource.data.fromUid == resource.data.fromUid;
    }

    /**
     * @description Manages project information. Allows read/write access to members of the project.
     * @path /projects/{projectId}
     * @allow (get, list) If the authenticated user is a member of the project.
     * @allow (create, update, delete) If the authenticated user is a member of the project.
     * @deny (get, list) If the authenticated user is not a member of the project.
     * @deny (create, update, delete) If the authenticated user is not a member of the project.
     * @principle Enforces shared access based on project membership.
     */
    match /projects/{projectId} {
      allow get, list: if isSignedIn() && request.auth.uid in resource.data.members;
      allow create: if isSignedIn() && request.resource.data.members.hasAll([request.auth.uid]) && request.resource.data.createdBy == request.auth.uid;
      allow update: if isSignedIn() && request.auth.uid in resource.data.members;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.members && resource != null;
    }

    /**
     * @description Manages tasks within a project.
     * @path /projects/{projectId}/tasks/{taskId}
     */
    match /projects/{projectId}/tasks/{taskId} {
      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.members.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.members.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.members.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/projects/$(projectId)).data.members.hasAny([request.auth.uid]) && resource != null;
    }

    /**
     * @description Manages invoice information. No specific write rules implemented in this prototype, all write access is denied.
     * @path /invoices/{invoiceId}
     * @allow (get, list) Public read access to invoice information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /invoices/{invoiceId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages line items within an invoice. No specific write rules implemented in this prototype, all write access is denied.
     * @path /invoices/{invoiceId}/lineItems/{lineItemId}
     */
    match /invoices/{invoiceId}/lineItems/{lineItemId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages client information. No specific write rules implemented in this prototype, all write access is denied.
     * @path /clients/{clientId}
     * @allow (get, list) Public read access to client information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /clients/{clientId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages expense information. No specific write rules implemented in this prototype, all write access is denied.
     * @path /expenses/{expenseId}
     * @allow (get, list) Public read access to expense information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /expenses/{expenseId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages time entry information. No specific write rules implemented in this prototype, all write access is denied.
     * @path /timeEntries/{timeEntryId}
     * @allow (get, list) Public read access to time entry information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /timeEntries/{timeEntryId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages document metadata. No specific write rules implemented in this prototype, all write access is denied.
     * @path /documents/{docId}
     * @allow (get, list) Public read access to document metadata.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /documents/{docId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages notification information. No specific write rules implemented in this prototype, all write access is denied.
     * @path /notifications/{notificationId}
     * @allow (get, list) Public read access to notification information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /notifications/{notificationId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages report data. No specific write rules implemented in this prototype, all write access is denied.
     * @path /reports/{reportId}
     * @allow (get, list) Public read access to report data.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /reports/{reportId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages portal view tokens for invoices. No specific write rules implemented in this prototype, all write access is denied.
     * @path /portalViews/{token}
     * @allow (get, list) Public read access to portal view tokens.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /portalViews/{token} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages kudos given to users. No specific write rules implemented in this prototype, all write access is denied.
     * @path /kudos/{kudoId}
     * @allow (get, list) Public read access to kudo information.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /kudos/{kudoId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages user presence status. No specific write rules implemented in this prototype, all write access is denied.
     * @path /presence/{uid}
     * @allow (get, list) Public read access to user presence status.
     * @deny (create, update, delete) All write operations are denied.
     * @principle Provides public read access but restricts all write access.
     */
    match /presence/{uid} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}